use anyhow::{anyhow, Result};
use image::GrayImage;
use tracing::{info, warn, debug};
use rxing::Reader;
use serde::{Deserialize, Serialize};

/// Represents the result of a successful QR code scan.
#[derive(Debug, Clone, Serialize, De    info    info    info    info!("üåê Fallback API - Sending request to http://localhost:8008/qr/hybrid-fallback");
    info!("üìä Fallback API - Request: multipart form with {} bytes", image_bytes.len());
    
    // Make the request to the Python fallback service
    let response = client
        .post("http://localhost:8008/qr/hybrid-fallback")
        .multipart(form)
        .send()
        .await;lback API - Sending request to http://localhost:8008/qr/hybrid-fallback");
    info!("üìä Fallback API - Request: multipart form with {} bytes", image_bytes.len());
    
    // Make the request to the Python fallback service
    let response = client
        .post("http://localhost:8008/qr/hybrid-fallback")
        .multipart(form)
        .send()
        .await;lback API - Sending request to http://localhost:8008/qr/hybrid-fallback");
    info!("üìä Fallback API - Request: multipart form with {} bytes", image_bytes.len());
    
    // Make the request to the Python fallback service
    let response = client
        .post("http://localhost:8008/qr/hybrid-fallback")
        .multipart(form)
        .send()
        .await;lback API - Sending request to http://localhost:8008/qr/hybrid-fallback");
    info!("üìä Fallback API - Request: multipart form with {} bytes", image_bytes.len());
    
    // Make the request to the Python fallback service
    let response = client
        .post("http://localhost:8008/qr/hybrid-fallback")
        .multipart(form)
        .send()
        .await;)]
pub struct QrScanResult {
    pub content: String,
    pub decoder: String,
    pub processing_time_ms: u64,
    pub level_used: u8, // 1 = Rust, 2 = Internal fallback
}

/// üöÄ HYBRID QR DETECTION - 2 Level Cascade Strategy
/// 
/// LEVEL 1 (85% success): Fast Rust decoders (rqrr ‚Üí quircs ‚Üí rxing)
/// LEVEL 2 (15% fallback): Internal API endpoint for complex cases
/// 
/// LEVEL 1 (85% success): Fast Rust decoders (rqrr ‚Üí quircs ‚Üí rxing)
/// LEVEL 2 (15% fallback): Internal API endpoint for complex cases
/// 
/// Memory optimized: Max 3MB per request vs 50MB in old ONNX version
/// Latency optimized: 5-15ms Rust, 30-50ms API fallback
pub async fn decode_qr_hybrid_cascade(image_bytes: &[u8]) -> Result<QrScanResult> {
    let start_time = std::time::Instant::now();
    
    info!("üîç Starting hybrid QR detection cascade");
    
    // LEVEL 1: Try fast Rust decoders first (target: 85% success rate)
    debug!("üìä LEVEL 1: Attempting Rust decoders...");
    if let Ok(mut result) = try_rust_decoders_optimized(image_bytes).await {
        result.level_used = 1;
        result.processing_time_ms = start_time.elapsed().as_millis() as u64;
        info!("‚úÖ LEVEL 1 SUCCESS: QR decoded with {} in {}ms", result.decoder, result.processing_time_ms);
        return Ok(result);
    }
    
    // LEVEL 2: Internal QR API fallback for complex cases (target: +12% success rate)
    warn!("‚ö†Ô∏è LEVEL 1 FAILED: Attempting internal QR API fallback...");
    debug!("üìä LEVEL 2: Attempting internal QR API fallback...");
    
    match try_internal_qr_api_fallback(image_bytes).await {
        Ok(mut result) => {
            result.level_used = 2;
            result.processing_time_ms = start_time.elapsed().as_millis() as u64;
            info!("‚úÖ LEVEL 2 SUCCESS: QR decoded with internal API fallback in {}ms", result.processing_time_ms);
            Ok(result)
        }
        Err(e) => {
            let total_time = start_time.elapsed().as_millis() as u64;
            warn!("‚ùå BOTH LEVELS FAILED: No QR code found after {}ms.", total_time);
            warn!("Internal API fallback error: {}", e);
            info!("üí° Tip: Ensure the internal QR API endpoint is working for improved detection");
            info!("üìä Final summary: Tried all Rust decoders (rqrr, quircs, rxing) in 3 strategies (fast, preprocessed, rotated)");
            
            Err(anyhow!("No QR code detected in image. Try with a clearer image or ensure the QR code is visible."))
        }
    }
}

/// LEVEL 1: Optimized Rust decoders cascade (sequential, memory efficient)
async fn try_rust_decoders_optimized(image_bytes: &[u8]) -> Result<QrScanResult> {
    // Load and convert to grayscale with variable shadowing for memory efficiency
    let image = image::load_from_memory(image_bytes)?;  // DynamicImage
    let gray_image = image.to_luma8();                  // GrayImage (DynamicImage freed)
    
    // Strategy 1: Try without preprocessing first (fastest path)
    debug!("üîÑ Strategy 1: Trying decoders without preprocessing...");
    
    info!("üìä Trying rqrr (fast path)...");
    if let Ok(content) = decode_with_rqrr_simple(&gray_image) {
        info!("‚úÖ rqrr SUCCESS: QR detected with content length {}", content.len());
        return Ok(QrScanResult { 
            content, 
            decoder: "rqrr_fast".to_string(),
            processing_time_ms: 0, // Will be set by caller
            level_used: 1,
        });
    }
    info!("‚ùå rqrr FAILED: No QR detected");
    
    info!("üìä Trying quircs (fast path)...");
    if let Ok(content) = decode_with_quircs_simple(&gray_image) {
        info!("‚úÖ quircs SUCCESS: QR detected with content length {}", content.len());
        return Ok(QrScanResult { 
            content, 
            decoder: "quircs_fast".to_string(),
            processing_time_ms: 0,
            level_used: 1,
        });
    }
    info!("‚ùå quircs FAILED: No QR detected");
    
    info!("üìä Trying rxing (fast path)...");
    if let Ok(content) = decode_with_rxing_simple(&gray_image) {
        info!("‚úÖ rxing SUCCESS: QR detected with content length {}", content.len());
        return Ok(QrScanResult { 
            content, 
            decoder: "rxing_fast".to_string(),
            processing_time_ms: 0,
            level_used: 1,
        });
    }
    info!("‚ùå rxing FAILED: No QR detected");
    
    // Strategy 2: Standard preprocessing (contrast + blur)
    debug!("üîÑ Strategy 2: Trying with standard preprocessing...");
    let image = image::load_from_memory(image_bytes)?;  // Reload for preprocessing
    let preprocessed = preprocess_image_for_qr(&image);  // Apply optimized preprocessing
    
    info!("üìä Trying rqrr (preprocessed)...");
    if let Ok(content) = decode_with_rqrr_simple(&preprocessed) {
        info!("‚úÖ rqrr SUCCESS (preprocessed): QR detected with content length {}", content.len());
        return Ok(QrScanResult { 
            content, 
            decoder: "rqrr_preprocessed".to_string(),
            processing_time_ms: 0,
            level_used: 1,
        });
    }
    info!("‚ùå rqrr FAILED (preprocessed): No QR detected");
    
    info!("üìä Trying quircs (preprocessed)...");
    if let Ok(content) = decode_with_quircs_simple(&preprocessed) {
        info!("‚úÖ quircs SUCCESS (preprocessed): QR detected with content length {}", content.len());
        return Ok(QrScanResult { 
            content, 
            decoder: "quircs_preprocessed".to_string(),
            processing_time_ms: 0,
            level_used: 1,
        });
    }
    info!("‚ùå quircs FAILED (preprocessed): No QR detected");
    
    info!("üìä Trying rxing (preprocessed)...");
    if let Ok(content) = decode_with_rxing_simple(&preprocessed) {
        info!("‚úÖ rxing SUCCESS (preprocessed): QR detected with content length {}", content.len());
        return Ok(QrScanResult { 
            content, 
            decoder: "rxing_preprocessed".to_string(),
            processing_time_ms: 0,
            level_used: 1,
        });
    }
    info!("‚ùå rxing FAILED (preprocessed): No QR detected");
    
    // Strategy 3: Aggressive transformations (rotate, scale, etc.)
    debug!("üîÑ Strategy 3: Trying aggressive transformations...");
    
    // Try rotations (common issue with mobile photos)
    for angle in [90.0f32, 180.0f32, 270.0f32] {
        info!("üìä Trying rotation {} degrees...", angle);
        let rotated = imageproc::geometric_transformations::rotate_about_center(
            &preprocessed, 
            angle.to_radians(), 
            imageproc::geometric_transformations::Interpolation::Bilinear,
            image::Luma([255u8])
        );
        
        info!("üìä Trying rqrr (rotated {})...", angle);
        if let Ok(content) = decode_with_rqrr_simple(&rotated) {
            info!("‚úÖ rqrr SUCCESS (rotated {}): QR detected with content length {}", angle, content.len());
            return Ok(QrScanResult { 
                content, 
                decoder: format!("rqrr_rotated_{}", angle),
                processing_time_ms: 0,
                level_used: 1,
            });
        }
        info!("‚ùå rqrr FAILED (rotated {}): No QR detected", angle);
        
        info!("üìä Trying quircs (rotated {})...", angle);
        if let Ok(content) = decode_with_quircs_simple(&rotated) {
            info!("‚úÖ quircs SUCCESS (rotated {}): QR detected with content length {}", angle, content.len());
            return Ok(QrScanResult { 
                content, 
                decoder: format!("quircs_rotated_{}", angle),
                processing_time_ms: 0,
                level_used: 1,
            });
        }
        info!("‚ùå quircs FAILED (rotated {}): No QR detected", angle);
        
        info!("üìä Trying rxing (rotated {})...", angle);
        if let Ok(content) = decode_with_rxing_simple(&rotated) {
            info!("‚úÖ rxing SUCCESS (rotated {}): QR detected with content length {}", angle, content.len());
            return Ok(QrScanResult { 
                content, 
                decoder: format!("rxing_rotated_{}", angle),
                processing_time_ms: 0,
                level_used: 1,
            });
        }
        info!("‚ùå rxing FAILED (rotated {}): No QR detected", angle);
    }
    
    debug!("‚ùå All Rust strategies failed (rqrr, quircs, rxing in all modes)");
    warn!("üîÑ Proceeding to LEVEL 2: Internal API fallback...");
    Err(anyhow!("All Rust decoders failed (rqrr, quircs, rxing)"))
}

/// LEVEL 2: Internal QR API fallback - Calls Python/OpenCV service
async fn try_internal_qr_api_fallback(image_bytes: &[u8]) -> Result<QrScanResult> {
    info!("üåê LEVEL 2: Starting internal QR API fallback...");
    
    // Check if we have basic image data
    if image_bytes.len() < 100 {
        warn!("‚ùå Fallback API: Image too small ({} bytes)", image_bytes.len());
        return Err(anyhow!("Image data too small for fallback API"));
    }
    
    // Detect image format
    let format = if image_bytes.starts_with(&[0xFF, 0xD8, 0xFF]) {
        "JPEG"
    } else if image_bytes.starts_with(&[0x89, 0x50, 0x4E, 0x47]) {
        "PNG"
    } else if image_bytes.len() > 12 && &image_bytes[8..12] == b"WEBP" {
        "WEBP"
    } else {
        "UNKNOWN"
    };
    
    info!("üìä Fallback API - Input: {} bytes, format: {}", image_bytes.len(), format);
    
    // Create HTTP client
    let client = reqwest::Client::new();
    
    // Prepare multipart form data (matching the expected format)
    let form = reqwest::multipart::Form::new()
        .part("file", reqwest::multipart::Part::bytes(image_bytes.to_vec())
            .file_name("qr_image.jpg")
            .mime_str("image/jpeg")?);
    
    info!("ÔøΩ Fallback API - Sending request to http://localhost:8000/api/v4/qr/detect");
    info!("üìä Fallback API - Request: multipart form with {} bytes", image_bytes.len());
    
    // Make the request to the Python fallback service
    let response = client
        .post("http://localhost:8000/api/v4/qr/detect")
        .multipart(form)
        .send()
        .await;
    
    match response {
        Ok(resp) => {
            let status = resp.status();
            info!("ÔøΩ Fallback API - Response status: {}", status);
            
            if status.is_success() {
                let response_text = resp.text().await?;
                info!("üì• Fallback API - Response body: {}", response_text);
                
                // Try to parse as JSON
                if let Ok(json_response) = serde_json::from_str::<serde_json::Value>(&response_text) {
                    if let Some(content) = json_response.get("content").and_then(|v| v.as_str()) {
                        info!("‚úÖ Fallback API SUCCESS: QR decoded with content length {}", content.len());
                        return Ok(QrScanResult {
                            content: content.to_string(),
                            decoder: "python_opencv_fallback".to_string(),
                            processing_time_ms: 0, // Will be set by caller
                            level_used: 2,
                        });
                    } else if let Some(error) = json_response.get("error").and_then(|v| v.as_str()) {
                        warn!("‚ùå Fallback API - Server error: {}", error);
                        return Err(anyhow!("Fallback API error: {}", error));
                    }
                }
                
                // If not JSON, check if it's plain text QR content
                if !response_text.trim().is_empty() && !response_text.contains("error") {
                    info!("‚úÖ Fallback API SUCCESS: QR decoded (plain text response)");
                    return Ok(QrScanResult {
                        content: response_text.trim().to_string(),
                        decoder: "python_opencv_fallback".to_string(),
                        processing_time_ms: 0,
                        level_used: 2,
                    });
                }
                
                warn!("‚ùå Fallback API - Unexpected response format: {}", response_text);
                Err(anyhow!("Fallback API returned unexpected format"))
            } else {
                let error_text = resp.text().await.unwrap_or_else(|_| "Unknown error".to_string());
                warn!("‚ùå Fallback API - HTTP error {}: {}", status, error_text);
                Err(anyhow!("Fallback API HTTP error: {} - {}", status, error_text))
            }
        }
        Err(e) => {
            warn!("‚ùå Fallback API - Connection error: {}", e);
            info!("üí° Fallback API - Check if Python/OpenCV service is running on port 8008");
            Err(anyhow!("Fallback API connection error: {}", e))
        }
    }
}

/// Attempts to decode a QR code using the rqrr library - OPTIMIZED
fn decode_with_rqrr_simple(image: &GrayImage) -> Result<String> {
    let mut prepared_img = rqrr::PreparedImage::prepare(image.clone()); // Minimal necessary clone
    let grids = prepared_img.detect_grids();

    if grids.is_empty() {
        return Err(anyhow!("rqrr: No grids found"));
    }

    let (_meta, content) = grids[0].decode()?;
    Ok(content)
}

/// Attempts to decode a QR code using the quircs library - OPTIMIZED
fn decode_with_quircs_simple(image: &GrayImage) -> Result<String> {
    let mut decoder = quircs::Quirc::default();
    let codes = decoder.identify(
        image.width() as usize,
        image.height() as usize,
        image // Pass reference directly
    );

    for code in codes {
        let code = code?;
        let decoded = code.decode()?;
        // Return the first successful decoding
        return Ok(String::from_utf8(decoded.payload)?);
    }
    Err(anyhow!("quircs: No QR code found"))
}

/// Attempts to decode a QR code using the rxing library - OPTIMIZED
fn decode_with_rxing_simple(image: &GrayImage) -> Result<String> {
    // Convert GrayImage to DynamicImage for rxing
    let dynamic_image = image::DynamicImage::ImageLuma8(image.clone());
    
    // Create a luminance source
    let mut multi_detector = rxing::MultiUseMultiFormatReader::default();
    
    let result = multi_detector.decode_with_hints(
        &mut rxing::BinaryBitmap::new(rxing::common::GlobalHistogramBinarizer::new(
            rxing::BufferedImageLuminanceSource::new(dynamic_image)
        )),
        &rxing::DecodingHintDictionary::new()
    )?;
    
    Ok(result.getText().to_string())
}

/// Apply optimized preprocessing to enhance QR detection
fn preprocess_image_for_qr(img: &image::DynamicImage) -> image::GrayImage {
    use imageproc::contrast::adaptive_threshold;
    use imageproc::filter::gaussian_blur_f32;
    
    // Convert to grayscale first
    let image = img.to_luma8();
    
    // Apply light Gaussian blur to reduce noise (variable shadowing saves memory)
    let image = gaussian_blur_f32(&image, 1.0); // 1.0 sigma - light blur
    
    // Apply adaptive thresholding for better contrast
    let mut image = adaptive_threshold(&image, 15); // 15x15 kernel size
    
    // Enhance contrast by stretching histogram
    for pixel in image.pixels_mut() {
        let val = pixel[0] as f32;
        let new_val = ((val / 255.0).powf(0.8) * 255.0) as u8; // Gamma correction
        pixel[0] = new_val;
    }
    
    image // Return the processed image
}
